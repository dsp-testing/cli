"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyTLogSET = void 0;
const util_1 = require("../util");
const format_1 = require("./format");
// Verifies that all of the tlog entries in the given bundle can be verified.
// Verification is peroformed by re-creating the original Rekor entry from the
// bundle and then verifying the SET against the entry using the corresponding
// key.
function verifyTLogSET(bundle, tlogKeys) {
    var _a;
    (_a = bundle.verificationData) === null || _a === void 0 ? void 0 : _a.tlogEntries.forEach((entry, index) => {
        var _a;
        // Re-create the original Rekor verification payload
        const payload = toVerificationPayload(bundle, index);
        // Canonicalize the payload and turn into a buffer for verification
        const data = Buffer.from(util_1.json.canonicalize(payload), 'utf8');
        // Find the public key for the transaction log which generated the SET
        const publicKey = tlogKeys[payload.logID];
        if (!publicKey) {
            throw new Error('no key found for logID: ' + payload.logID);
        }
        // Extract the SET from the tlog entry
        const signature = (_a = entry.inclusionPromise) === null || _a === void 0 ? void 0 : _a.signedEntryTimestamp;
        if (!signature) {
            throw new Error('no SET found in bundle');
        }
        if (!util_1.crypto.verifyBlob(data, publicKey, signature)) {
            throw new Error('transparency log SET verification failed');
        }
    });
}
exports.verifyTLogSET = verifyTLogSET;
// Returns a properly formatted "VerificationPayload" for one of the
// transaction log entires in the given bundle which can be used for SET
// verification.
function toVerificationPayload(bundle, index = 0) {
    var _a;
    // Ensure bundle has tlog entries
    const entries = (_a = bundle.verificationData) === null || _a === void 0 ? void 0 : _a.tlogEntries;
    if (!entries || entries.length - 1 < index) {
        throw new Error('No tlog entries found in bundle');
    }
    // Rekor metadata
    const { integratedTime, logIndex, logId } = entries[index];
    if (!logId) {
        throw new Error('No logId found in bundle');
    }
    // Recreate the Rekor entry from the bundle
    const body = toVerificationBody(bundle);
    return {
        body: util_1.encoding.base64Encode(util_1.json.canonicalize(body)),
        integratedTime: Number(integratedTime),
        logIndex: Number(logIndex),
        logID: logId.keyId.toString('hex'),
    };
}
// Recreates the original Rekor entry from the bundle.
function toVerificationBody(bundle) {
    var _a;
    // Extract the public key (or signing cert) from the bundle
    if (!bundle.verificationMaterial) {
        throw new Error('No verification material found in bundle');
    }
    const publicKey = toPublicKey(bundle.verificationMaterial);
    switch ((_a = bundle.content) === null || _a === void 0 ? void 0 : _a.$case) {
        case 'messageSignature': {
            return toMessageSignatureVerificationBody(bundle.content.messageSignature, publicKey);
        }
        case 'dsseEnvelope': {
            return toDSSEVerificationBody(bundle.content.dsseEnvelope, publicKey);
        }
        default:
            throw new Error('Unsupported bundle type');
    }
}
function toPublicKey(verificationMaterial) {
    var _a;
    switch ((_a = verificationMaterial === null || verificationMaterial === void 0 ? void 0 : verificationMaterial.content) === null || _a === void 0 ? void 0 : _a.$case) {
        case 'x509CertificateChain': {
            const der = verificationMaterial.content.x509CertificateChain.certificates[0];
            return util_1.pem.fromDER(der.rawBytes);
        }
        case 'publicKey':
        // TODO: How to handle this?
        // eslint-disable-next-line no-fallthrough
        default:
            throw new Error('No certificate found in bundle');
    }
}
// Recreates a Rekor "hashedrekord" entry from the bundle.
function toMessageSignatureVerificationBody(messageSignature, certificate) {
    var _a;
    const digest = ((_a = messageSignature.messageDigest) === null || _a === void 0 ? void 0 : _a.digest) || Buffer.from('');
    const sig = messageSignature.signature;
    const sigMaterial = {
        signature: sig,
        certificates: [certificate],
        key: undefined,
    };
    return (0, format_1.toProposedHashedRekordEntry)(digest, sigMaterial);
}
// Recreates a Rekor "intoto" entry from the bundle.
function toDSSEVerificationBody(dsseEnvelope, certificate) {
    var _a, _b;
    const sig = dsseEnvelope.signatures[0].sig;
    const sigMaterial = {
        signature: sig,
        certificates: [certificate],
        key: undefined,
    };
    const body = (0, format_1.toProposedIntotoEntry)(dsseEnvelope, sigMaterial);
    // When Rekor saves the entry it removes the payload from the envelope
    if (body.apiVersion === '0.0.2') {
        (_b = (_a = body.spec.content) === null || _a === void 0 ? void 0 : _a.envelope) === null || _b === void 0 ? true : delete _b.payload;
    }
    return body;
}
