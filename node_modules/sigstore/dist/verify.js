"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Verifier = void 0;
const error_1 = require("./error");
const verify_1 = require("./tlog/verify");
const util_1 = require("./util");
class Verifier {
    constructor(options) {
        this.tlog = options.tlog;
        this.tlogKeys = options.tlogKeys;
    }
    verifyOffline(bundle, data) {
        verifyArtifactSignature(bundle, data);
        (0, verify_1.verifyTLogSET)(bundle, this.tlogKeys);
    }
}
exports.Verifier = Verifier;
// Performs bundle signature verification. Determines the type of the bundle
// content and delegates to the appropriate signature verification function.
function verifyArtifactSignature(bundle, data) {
    var _a;
    switch ((_a = bundle.content) === null || _a === void 0 ? void 0 : _a.$case) {
        case 'messageSignature':
            if (!data) {
                throw new error_1.VerificationError('No data provided for message signature verification');
            }
            verifyMessageSignature(bundle, data);
            break;
        case 'dsseEnvelope':
            verifyDSSESignature(bundle);
            break;
        default:
            throw new error_1.VerificationError('Bundle is invalid');
    }
}
// Performs signature verification for bundle containing a message signature.
// Verifies the signature found in the bundle against the provided data.
function verifyMessageSignature(bundle, data) {
    var _a;
    if (((_a = bundle.content) === null || _a === void 0 ? void 0 : _a.$case) !== 'messageSignature') {
        throw new error_1.VerificationError('No message signature found in bundle');
    }
    // Extract signature for message
    const signature = bundle.content.messageSignature.signature;
    // Get signing certificate containing public key
    const publicKey = getSigningCertificate(bundle);
    if (!util_1.crypto.verifyBlob(data, publicKey, signature)) {
        throw new error_1.VerificationError('Artifact signature verification failed');
    }
}
// Performs signature verification for bundle containing a DSSE envelope.
// Calculates the PAE for the DSSE envelope and verifies it against the
// signature in the envelope.
function verifyDSSESignature(bundle) {
    var _a;
    if (((_a = bundle.content) === null || _a === void 0 ? void 0 : _a.$case) !== 'dsseEnvelope') {
        throw new error_1.VerificationError('Bundle is not a DSSE envelope');
    }
    // Construct payload over which the signature was originally created
    const payloadType = bundle.content.dsseEnvelope.payloadType;
    const payload = bundle.content.dsseEnvelope.payload;
    const data = util_1.dsse.preAuthEncoding(payloadType, payload);
    // Extract signature from DSSE envelope
    if (bundle.content.dsseEnvelope.signatures.length < 1) {
        throw new error_1.VerificationError('No signatures found in DSSE envelope');
    }
    // TODO: Support multiple signatures
    const signature = bundle.content.dsseEnvelope.signatures[0].sig;
    // Get signing certificate containing public key
    const publicKey = getSigningCertificate(bundle);
    if (!util_1.crypto.verifyBlob(data, publicKey, signature)) {
        throw new error_1.VerificationError('Artifact signature verification failed');
    }
}
// Extracts the signing certificate from the bundle and formats it as a
// PEM-encoded string.
function getSigningCertificate(bundle) {
    var _a, _b;
    if (((_b = (_a = bundle.verificationMaterial) === null || _a === void 0 ? void 0 : _a.content) === null || _b === void 0 ? void 0 : _b.$case) !== 'x509CertificateChain') {
        throw new error_1.VerificationError('No certificate found in bundle');
    }
    const signingCert = bundle.verificationMaterial.content.x509CertificateChain.certificates[0];
    if (!signingCert) {
        throw new error_1.VerificationError('No certificate found in bundle');
    }
    return util_1.pem.fromDER(signingCert.rawBytes);
}
